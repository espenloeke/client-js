{"version":3,"sources":["webpack://FHIR/webpack/bootstrap","webpack://FHIR/./src/smart.js","webpack://FHIR/./src/Client.js","webpack://FHIR/./src/lib.js","webpack://FHIR/./src/browser.js","webpack://FHIR/./src/adapters/BrowserAdapter.js","webpack://FHIR/./src/storage/BrowserStorage.js","webpack://FHIR/./src/adapters/BaseAdapter.js","webpack://FHIR/(webpack)/buildin/global.js","webpack://FHIR/./src/HttpError.js","webpack://FHIR/./src/strings.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Client","require","isBrowser","request","getPath","randomString","btoa","SMART_KEY","fetchConformanceStatement","baseUrl","url","String","replace","catch","ex","Error","fetchWellKnownJson","message","getSecurityExtensions","then","meta","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","authorizeUri","tokenUri","metadata","extensions","filter","e","map","extension","out","forEach","ext","valueUri","async","authorize","env","params","_noRedirect","iss","launch","fhirServiceUrl","redirect_uri","redirectUri","scope","clientSecret","fakeTokenResponse","patientId","encounterId","client_id","clientId","getUrl","storage","getStorage","searchParams","relative","serverUrl","match","unset","stateKey","state","tokenResponse","assign","patient","encounter","redirectUrl","encodeURIComponent","set","redirect","redirectParams","push","join","completeAuth","Storage","code","authError","authErrorDescription","msg","Boolean","fullSessionStorageSupport","hasState","has","delete","window","history","replaceState","href","requestOptions","buildTokenRequest","access_token","method","headers","content-type","body","Authorization","ready","onSuccess","onError","task","init","options","cached","Promise","resolve","KEY","absolute","setPath","jwtDecode","makeArray","byCode","byCodes","units","str","resolveRefs","obj","fhirOptions","cache","client","paths","resolveReferences","path","trim","indexOf","length","groups","len","split","keys","sort","group","all","graph","node","isArray","Array","item","ref","reference","refId","sub","error","getRef","resolveRef","constructor","environment","_state","this","id","getPatientId","read","reject","getEncounterId","user","fhirUser","getFhirUser","getUserId","resourceType","getUserType","fhir","connect","fhirJs","accessToken","auth","token","username","password","pass","api","getIdToken","idToken","id_token","profile","getAuthorizationHeader","[object Object]","_resolvedRefs","URL","authHeader","flat","pageLimit","hasPageCallback","onPage","status","useRefreshToken","refresh","_clearState","expired","data","Response","entry","resource","links","link","next","find","relation","nextPage","references","concat","refreshToken","_refreshTask","refresh_token","finally","observations","global","HttpError","checkResponse","resp","ok","humanizeError","responseToJSON","text","JSON","parse","statusText","type","json","error_description","stringify","_","arg","atob","Buffer","from","toString","ret","handleCodeableConcept","concept","observation","coding","ensureNumerical","cm","kg","any","pq","stripTrailingSlash","reduce","undefined","idx","arr","strLength","charSet","result","charAt","Math","floor","random","payload","fetch","accept","res","bank","codes","prev","smart","oauth2","settings","BrowserStorage","BaseAdapter","BrowserAdapter","_url","location","to","_storage","getSmartApi","Adapter","sessionStorage","replaceBrowserHistory","args","g","Function","statusCode","super","toJSON","failure","responseText","noScopeForId","noIfNoAuth","noFreeContext"],"mappings":"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","file":"fhir-client.pure.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const Client  = require(\"./Client\");\nconst {\n    isBrowser,\n\n\n    request,\n    getPath,\n    randomString,\n    btoa\n} = require(\"./lib\");\n\n\nconst SMART_KEY = \"SMART_KEY\";\n\nfunction fetchConformanceStatement(baseUrl = \"/\")\n{\n    const url = String(baseUrl).replace(/\\/*$/, \"/\") + \"metadata\";\n    return request(url).catch(ex => {\n        throw new Error(`Failed to fetch the conformance statement from \"${url}\". ${ex}`);\n    });\n}\n\nfunction fetchWellKnownJson(baseUrl = \"/\")\n{\n    const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n    return request(url).catch(ex => {\n        throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n    });\n}\n\n/**\n * Given a fhir server returns an object with it's Oauth security endpoints that\n * we are interested in\n * @param {String} baseUrl Fhir server base URL\n * @returns { Promise<fhirclient.OAuthSecurityExtensions> }\n */\nfunction getSecurityExtensions(baseUrl = \"/\")\n{\n    return fetchWellKnownJson(baseUrl).then(meta => {\n        if (!meta.authorization_endpoint || !meta.token_endpoint) {\n            throw new Error(\"Invalid wellKnownJson\");\n        }\n        return {\n            registrationUri: meta.registration_endpoint  || \"\",\n            authorizeUri   : meta.authorization_endpoint,\n            tokenUri       : meta.token_endpoint\n        };\n    }).catch(() => fetchConformanceStatement(baseUrl).then(metadata => {\n        const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n        const extensions = (getPath(metadata || {}, \"rest.0.security.extension\") || [])\n            .filter(e => e.url === nsUri)\n            .map(o => o.extension)[0];\n\n        const out = {\n            registrationUri : \"\",\n            authorizeUri    : \"\",\n            tokenUri        : \"\"\n        };\n\n        if (extensions) {\n            extensions.forEach(ext => {\n                if (ext.url === \"register\") {\n                    out.registrationUri = ext.valueUri;\n                }\n                if (ext.url === \"authorize\") {\n                    out.authorizeUri = ext.valueUri;\n                }\n                if (ext.url === \"token\") {\n                    out.tokenUri = ext.valueUri;\n                }\n            });\n        }\n\n        return out;\n    }));\n}\n\n/**\n * @param {Object} env\n * @param {fhirclient.AuthorizeParams} params\n * @param {Boolean} [_noRedirect = false] If true, resolve with the redirect url\n * without trying to redirect to it\n * @returns { Promise<never|string> }\n */\nasync function authorize(env, params = {}, _noRedirect = false)\n{\n    // Obtain input\n    let {\n        iss,\n        launch,\n        fhirServiceUrl,\n        redirect_uri,\n        redirectUri,\n        scope = \"\",\n        clientSecret,\n        fakeTokenResponse,\n        patientId,\n        encounterId,\n        client_id,\n        clientId\n    } = params;\n\n    const url     = env.getUrl();\n    const storage = env.getStorage();\n\n    // For these three an url param takes precedence over inline option\n    iss            = url.searchParams.get(\"iss\")            || iss;\n    fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n    launch         = url.searchParams.get(\"launch\")         || launch;\n\n    if (!clientId) {\n        clientId = client_id;\n    }\n\n    if (!redirectUri) {\n        redirectUri = redirect_uri;\n    }\n\n    if (!redirectUri) {\n        redirectUri = env.relative(\".\");\n    } else {\n        redirectUri = env.relative(redirectUri);\n    }\n\n    const serverUrl = String(iss || fhirServiceUrl || \"\");\n\n    // Validate input\n    if (!serverUrl) {\n        throw new Error(\n            \"No server url found. It must be specified as `iss` or as \" +\n            \"`fhirServiceUrl` parameter\"\n        );\n    }\n\n\n    // append launch scope if needed\n    if (launch && !scope.match(/launch/)) {\n        scope += \" launch\";\n    }\n\n    // prevent inheritance of tokenResponse from parent window\n    await storage.unset(SMART_KEY);\n\n    // create initial state\n    const stateKey = randomString(16);\n    const state = {\n        clientId,\n        scope,\n        redirectUri,\n        serverUrl,\n        clientSecret,\n        tokenResponse: {},\n        key: stateKey\n    };\n\n    // fakeTokenResponse to override stuff (useful in development)\n    if (fakeTokenResponse) {\n        Object.assign(state.tokenResponse, fakeTokenResponse);\n    }\n\n    // Fixed patientId (useful in development)\n    if (patientId) {\n        Object.assign(state.tokenResponse, { patient: patientId });\n    }\n\n    // Fixed encounterId (useful in development)\n    if (encounterId) {\n        Object.assign(state.tokenResponse, { encounter: encounterId });\n    }\n\n    let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey);\n\n    // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n    if (fhirServiceUrl && !iss) {\n        // Storage.set(stateKey, state);\n        await storage.set(stateKey, state);\n        if (_noRedirect) {\n            return redirectUrl;\n        }\n        return await env.redirect(redirectUrl);\n    }\n\n    // Get oauth endpoints and add them to the state\n    const extensions = await getSecurityExtensions(serverUrl);\n    Object.assign(state, extensions);\n    await storage.set(stateKey, state);\n\n    // If this happens to be an open server and there is no authorizeUri\n    if (!state.authorizeUri) {\n        if (_noRedirect) {\n            return redirectUrl;\n        }\n        return await env.redirect(redirectUrl);\n    }\n\n    // build the redirect uri\n    const redirectParams = [\n        \"response_type=code\",\n        \"client_id=\"    + encodeURIComponent(clientId),\n        \"scope=\"        + encodeURIComponent(scope),\n        \"redirect_uri=\" + encodeURIComponent(redirectUri),\n        \"aud=\"          + encodeURIComponent(serverUrl),\n        \"state=\"        + encodeURIComponent(stateKey)\n    ];\n\n    // also pass this in case of EHR launch\n    if (launch) {\n        redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n    }\n\n    redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n    if (_noRedirect) {\n        return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n}\n\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n * @returns { Promise<fhirclient.Client> }\n */\nasync function completeAuth(env)\n{\n    const url = env.getUrl();\n    const Storage = env.getStorage();\n    const params = url.searchParams;\n\n    let key                    = params.get(\"state\");\n    const code                 = params.get(\"code\");\n    const authError            = params.get(\"error\");\n    const authErrorDescription = params.get(\"error_description\");\n\n    if (!key) {\n        key = await Storage.get(SMART_KEY);\n    }\n\n    // Start by checking the url for `error` and `error_description` parameters.\n    // This happens when the auth server rejects our authorization attempt. In\n    // this case it has no other way to tell us what the error was, other than\n    // appending these parameters to the redirect url.\n    // From client's point of view, this is not very reliable (because we can't\n    // know how we have landed on this page - was it a redirect or was it loaded\n    // manually). However, if `completeAuth()` is being called, we can assume\n    // that the url comes from the auth server (otherwise the app won't work\n    // anyway).\n    if (authError || authErrorDescription) {\n        let msg = [authError, authErrorDescription].filter(Boolean).join(\": \");\n        throw new Error(msg);\n    }\n\n\n    // key might be coming from the page url so it might be empty or missing\n    if (!key) {\n        throw new Error(\"No 'state' parameter found. Please (re)launch the app.\");\n    }\n\n    // Check if we have a previous state\n    let state = await Storage.get(key);\n\n    const fullSessionStorageSupport = isBrowser() ?\n        getPath(env, \"options.fullSessionStorageSupport\") :\n        true;\n\n    // Do we have to remove the `code` and `state` params from the URL?\n    const hasState = params.has(\"state\");\n\n    if (isBrowser() && getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n\n        // `code` is the flag that tell us to request an access token.\n        // We have to remove it, otherwise the page will authorize on\n        // every load!\n        if (code) {\n            params.delete(\"code\");\n        }\n\n        // If we have `fullSessionStorageSupport` it means we no longer\n        // need the `state` key. It will be stored to a well know\n        // location - sessionStorage[SMART_KEY]. However, no\n        // fullSessionStorageSupport means that this \"well know location\"\n        // might be shared between windows and tabs. In this case we\n        // MUST keep the `state` url parameter.\n        if (hasState && fullSessionStorageSupport) {\n            params.delete(\"state\");\n        }\n\n        // If the browser does not support the replaceState method for the\n        // History Web API, the \"code\" parameter cannot be removed. As a\n        // consequence, the page will (re)authorize on every load. The\n        // workaround is to reload the page to new location without those\n        // parameters. If that is not acceptable replaceBrowserHistory\n        // should be set to false.\n        if (window.history.replaceState) {\n            window.history.replaceState({}, \"\", url.href);\n        }\n    }\n\n    // If the state does not exist, it means the page has been loaded directly.\n    if (!state) {\n        throw new Error(\"No state found! Please (re)launch the app.\");\n    }\n\n    // If we have state, then check to see if we got a `code`. If we don't,\n    // then this is just a reload. Otherwise, we have to complete the code flow\n    if (code) {\n        const requestOptions = await buildTokenRequest(code, state);\n        // The EHR authorization server SHALL return a JSON structure that\n        // includes an access token or a message indicating that the\n        // authorization request has been denied.\n        let tokenResponse = await request(state.tokenUri, requestOptions);\n        if (!tokenResponse.access_token) {\n            throw new Error(\"Failed to obtain access token.\");\n        }\n        // save the tokenResponse so that we don't have to re-authorize on\n        // every page reload\n        state = { ...state, tokenResponse };\n        await Storage.set(key, state);\n        if (fullSessionStorageSupport) {\n            await Storage.set(SMART_KEY, key);\n        }\n    }\n\n    const client = new Client(env, state);\n    return client;\n}\n\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\nfunction buildTokenRequest(code, state)\n{\n    const { redirectUri, clientSecret, tokenUri, clientId } = state;\n\n    if (!redirectUri) {\n        throw new Error(\"Missing state.redirectUri\");\n    }\n\n    if (!tokenUri) {\n        throw new Error(\"Missing state.tokenUri\");\n    }\n\n    if (!clientId) {\n        throw new Error(\"Missing state.clientId\");\n    }\n\n    const requestOptions = {\n        method: \"POST\",\n        headers: { \"content-type\": \"application/x-www-form-urlencoded\" },\n        body: `code=${code}&grant_type=authorization_code&redirect_uri=${\n            encodeURIComponent(redirectUri)}`\n    };\n\n    // For public apps, authentication is not possible (and thus not required),\n    // since a client with no secret cannot prove its identity when it issues a\n    // call. (The end-to-end system can still be secure because the client comes\n    // from a known, https protected endpoint specified and enforced by the\n    // redirect uri.) For confidential apps, an Authorization header using HTTP\n    // Basic authentication is required, where the username is the app’s\n    // client_id and the password is the app’s client_secret (see example).\n    if (clientSecret) {\n        requestOptions.headers.Authorization = \"Basic \" + btoa(\n            clientId + \":\" + clientSecret\n        );\n    } else {\n        requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n    }\n\n    return requestOptions;\n}\n\n/**\n * @param {Object} env\n * @param {() => Promise<fhirclient.Client>} [onSuccess]\n * @param {() => never} [onError]\n * @returns { Promise<fhirclient.Client> }\n */\nasync function ready(env, onSuccess, onError)\n{\n    let task = completeAuth(env);\n    if (onSuccess) {\n        task = task.then(onSuccess);\n    }\n    if (onError) {\n        task = task.catch(onError);\n    }\n    return task;\n}\n\nasync function init(env, options)\n{\n    const url   = env.getUrl();\n    const code  = url.searchParams.get(\"code\");\n    const state = url.searchParams.get(\"state\");\n\n    // if `code` and `state` params are present we need to complete the auth flow\n    if (code && state) {\n        return completeAuth(env);\n    }\n\n    // Check for existing client state. If state is found, it means a client\n    // instance have already been created in this session and we should try to\n    // \"revive\" it.\n    const storage = env.getStorage();\n    const key     = state || await storage.get(SMART_KEY);\n    const cached  = await storage.get(key);\n    if (cached) {\n        return Promise.resolve(new Client(env, cached));\n    }\n\n    // Otherwise try to launch\n    return authorize(env, options).then(() => {\n        // `init` promises a Client but that cannot happen in this case. The\n        // browser will be redirected (unload the page and be redirected back\n        // to it later and the same init function will be called again). On\n        // success, authorize will resolve with the redirect url but we don't\n        // want to return that from this promise chain because it is not a\n        // Client instance. At the same time, if authorize fails, we do want to\n        // pass the error to those waiting for a client instance.\n        return new Promise(() => { /* leave it pending!!! */ });\n    });\n}\n\nmodule.exports = {\n    fetchConformanceStatement,\n    fetchWellKnownJson,\n    getSecurityExtensions,\n    buildTokenRequest,\n    authorize,\n    completeAuth,\n    ready,\n    init,\n    KEY: SMART_KEY\n};\n","/// <reference path=\"types.d.ts\" />\nconst {\n    absolute,\n\n\n    getPath,\n    setPath,\n    jwtDecode,\n    makeArray,\n    request,\n    btoa,\n    byCode,\n    byCodes,\n    units\n} = require(\"./lib\");\n\n\nconst str = require(\"./strings\");\n\n/**\n * Gets single reference by id. Caches the result.\n * @param {String} refId\n * @param {Object} cache A map to store the resolved refs\n * @param {FhirClient} client The client instance\n * @returns {Promise<Object>} The resolved reference\n * @private\n */\nfunction getRef(refId, cache, client) {\n    let sub = cache[refId];\n    if (!sub) {\n        // Note that we set cache[refId] immediately! When the promise is settled\n        // it will be updated. This is to avoid a ref being fetched twice because\n        // some of these requests are executed in parallel.\n        cache[refId] = client.request(refId).then(sub => {\n            cache[refId] = sub;\n            return sub;\n        }, error => {\n            delete cache[refId];\n            throw error;\n        });\n        return cache[refId];\n    }\n    return sub;\n}\n\n/**\n * Resolves a reference in the given resource.\n * @param {Object} obj FHIR Resource\n */\nfunction resolveRef(obj, path, graph, cache, client) {\n    const node = getPath(obj, path);\n    if (node) {\n        const isArray = Array.isArray(node);\n        return Promise.all(makeArray(node).map((item, i) => {\n            const ref = item.reference;\n            if (ref) {\n                return getRef(ref, cache, client).then(sub => {\n                    if (graph) {\n                        if (isArray) {\n                            setPath(obj, `${path}.${i}`, sub);\n                        } else {\n                            setPath(obj, path, sub);\n                        }\n                    }\n                }).catch(() => { /* ignore */ });\n            }\n        }));\n    }\n}\n\n/**\n * Given a resource and a list of ref paths - resolves them all\n * @param {Object} obj FHIR Resource\n * @param {Object} fhirOptions The fhir options of the initiating request call\n * @param {Object} cache A map to store fetched refs\n * @param {FhirClient} client The client instance\n * @private\n */\nfunction resolveRefs(obj, fhirOptions, cache, client) {\n\n    // 1. Sanitize paths, remove any invalid ones\n    let paths = makeArray(fhirOptions.resolveReferences)\n        .filter(Boolean) // No false, 0, null, undefined or \"\"\n        .map(path => String(path).trim())\n        .filter(Boolean); // No space-only strings\n\n    // 2. Remove duplicates\n    paths = paths.filter((p, i) => {\n        let index = paths.indexOf(p, i + 1);\n        if (index > -1) {\n            return false;\n        }\n        return true;\n    });\n\n    // 3. Early exit if no valid paths are found\n    if (!paths.length) {\n        return Promise.resolve();\n    }\n\n    // 4. Group the paths by depth so that child refs are looked up\n    // after their parents!\n    const groups = {};\n    paths.forEach(path => {\n        const len = path.split(\".\").length;\n        if (!groups[len]) {\n            groups[len] = [];\n        }\n        groups[len].push(path);\n    });\n\n    // 5. Execute groups sequentially! Paths within same group are\n    // fetched in parallel!\n    /**\n     * @type any\n     */\n    let task = Promise.resolve();\n    Object.keys(groups).sort().forEach(len => {\n        const group = groups[len];\n        task = task.then(() => Promise.all(group.map(path => {\n            return resolveRef(obj, path, fhirOptions.graph, cache, client);\n        })));\n    });\n    return task;\n}\n\n/**\n * @implements { fhirclient.Client }\n */\nclass FhirClient\n{\n    /**\n     * @param {object} environment\n     * @param {fhirclient.ClientState|string} state\n     */\n    constructor(environment, state)\n    {\n        /**\n         * @type fhirclient.ClientState\n         */\n        const _state = typeof state == \"string\" ? { serverUrl: state } : state;\n\n        // Valid serverUrl is required!\n        if (!_state.serverUrl || !_state.serverUrl.match(/https?:\\/\\/.+/)) {\n            throw new Error(\"A \\\"serverUrl\\\" option is required and must begin with \\\"http(s)\\\"\");\n        }\n\n        this.state = _state;\n        this.environment = environment;\n\n        const client = this;\n\n        // patient api ---------------------------------------------------------\n        this.patient = {\n            get id() { return client.getPatientId(); },\n            read: () => {\n                const id = this.patient.id;\n                return id ?\n                    this.request(`Patient/${id}`) :\n                    Promise.reject(new Error(\"Patient is not available\"));\n            }\n        };\n\n        // encounter api -------------------------------------------------------\n        this.encounter = {\n            get id() { return client.getEncounterId(); },\n            read: () => {\n                const id = this.encounter.id;\n                return id ?\n                    this.request(`Encounter/${id}`) :\n                    Promise.reject(new Error(\"Encounter is not available\"));\n            }\n        };\n\n        // user api ------------------------------------------------------------\n        this.user = {\n            get fhirUser() { return client.getFhirUser(); },\n            get id() { return client.getUserId(); },\n            get resourceType() { return client.getUserType(); },\n            read: () => {\n                const fhirUser = this.user.fhirUser;\n                return fhirUser ?\n                    this.request(fhirUser) :\n                    Promise.reject(new Error(\"User is not available\"));\n            }\n        };\n\n        // fhir.js api (attached automatically in browser)\n        // ---------------------------------------------------------------------\n        if (environment.fhir) {\n            this.connect(environment.fhir);\n        }\n    }\n\n    connect(fhirJs)\n    {\n        if (typeof fhirJs == \"function\") {\n            const options = {\n                baseUrl: this.state.serverUrl.replace(/\\/$/, \"\")\n            };\n\n            const accessToken = getPath(this, \"state.tokenResponse.access_token\");\n            if (accessToken) {\n                options.auth = { token: accessToken };\n            }\n            else {\n                const { username, password } = this.state;\n                if (username && password) {\n                    options.auth = {\n                        user: username,\n                        pass: password\n                    };\n                }\n            }\n            this.api = fhirJs(options);\n\n            const patientId = getPath(this, \"state.tokenResponse.patient\");\n            if (patientId) {\n                this.patient.api = fhirJs({\n                    ...options,\n                    patient: patientId\n                });\n            }\n        }\n    }\n\n    /**\n     * Returns the ID of the selected patient or null. You should have requested\n     * \"launch/patient\" scope. Otherwise this will return null.\n     */\n    getPatientId()\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            // We have been authorized against this server but we don't know\n            // the patient. This should be a scope issue.\n            if (!tokenResponse.patient) {\n                return null;\n            }\n            return tokenResponse.patient;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the ID of the selected encounter or null. You should have\n     * requested \"launch/encounter\" scope. Otherwise this will return null.\n     * Note that not all servers support the \"launch/encounter\" scope so this\n     * will be null if they don't.\n     */\n    getEncounterId()\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            // We have been authorized against this server but we don't know\n            // the encounter. This should be a scope issue.\n            if (!tokenResponse.encounter) {\n                return null;\n            }\n            return tokenResponse.encounter;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns the (decoded) id_token if any. You need to request \"openid\" and\n     * \"profile\" scopes if you need to receive an id_token (if you need to know\n     * who the logged-in user is).\n     */\n    getIdToken()\n    {\n        const tokenResponse = this.state.tokenResponse;\n        if (tokenResponse) {\n            const idToken = tokenResponse.id_token;\n            const scope = this.state.scope || \"\";\n\n            // We have been authorized against this server but we don't have\n            // the id_token. This should be a scope issue.\n            if (!idToken) {\n                return null;\n            }\n            return jwtDecode(idToken);\n        }\n        return null;\n    }\n\n    /**\n     * Returns the profile of the logged_in user (if any). This is a string\n     * having the following shape \"{user type}/{user id}\". For example:\n     * \"Practitioner/abc\" or \"Patient/xyz\".\n     */\n    getFhirUser()\n    {\n        const idToken = this.getIdToken();\n        if (idToken) {\n            return idToken.profile;\n        }\n        return null;\n    }\n\n    /**\n     * Returns the user ID or null.\n     */\n    getUserId()\n    {\n        const profile = this.getFhirUser();\n        if (profile) {\n            return profile.split(\"/\")[1];\n        }\n        return null;\n    }\n\n    /**\n     * Returns the type of the logged-in user or null. The result can be\n     * \"Practitioner\", \"Patient\" or \"RelatedPerson\".\n     */\n    getUserType()\n    {\n        const profile = this.getFhirUser();\n        if (profile) {\n            return profile.split(\"/\")[0];\n        }\n        return null;\n    }\n\n    getAuthorizationHeader()\n    {\n        const accessToken = getPath(this, \"state.tokenResponse.access_token\");\n        if (accessToken) {\n            return \"Bearer \" + accessToken;\n        }\n        const { username, password } = this.state;\n        if (username && password) {\n            return \"Basic \" + btoa(username + \":\" + password);\n        }\n        return null;\n    }\n\n    async _clearState() {\n        const { KEY } = require(\"./smart\");\n        const storage = this.environment.getStorage();\n        const key = await storage.get(KEY);\n        if (key) {\n            await storage.unset(key);\n        }\n        await storage.unset(KEY);\n        this.state.tokenResponse = {};\n    }\n\n    /**\n     * @param {Object|String} requestOptions Can be a string URL (relative to\n     *  the serviceUrl), or an object which will be passed to fetch()\n     * @param {fhirclient.FhirOptions} fhirOptions Additional options to control the behavior\n     * @param {object} _resolvedRefs DO NOT USE! Used internally.\n     */\n    async request(requestOptions, fhirOptions = {}, _resolvedRefs = {})\n    {\n        if (!requestOptions) {\n            throw new Error(\"request requires an url or request options as argument\");\n        }\n\n        // url -----------------------------------------------------------------\n        let url;\n        if (typeof requestOptions == \"string\" || requestOptions instanceof URL) {\n            url = String(requestOptions);\n            requestOptions = {};\n        }\n        else {\n            url = String(requestOptions.url);\n        }\n\n        url = absolute(url, this.state.serverUrl);\n\n        // authentication ------------------------------------------------------\n        const authHeader = this.getAuthorizationHeader();\n        if (authHeader) {\n            requestOptions.headers = {\n                ...requestOptions.headers,\n                Authorization: authHeader\n            };\n        }\n\n        // fhirOptions.graph ---------------------------------------------------\n        fhirOptions.graph = (fhirOptions.graph !== false);\n\n        // fhirOptions.flat ----------------------------------------------------\n        fhirOptions.flat = !!fhirOptions.flat;\n\n        // fhirOptions.pageLimit -----------------------------------------------\n        if (!fhirOptions.pageLimit && fhirOptions.pageLimit !== 0) {\n            fhirOptions.pageLimit = 1;\n        }\n\n        const hasPageCallback = typeof fhirOptions.onPage == \"function\";\n\n\n        return request(url, requestOptions)\n\n            // Automatic re-auth via refresh token -----------------------------\n            .catch(error => {\n                if (error.status == 401 && fhirOptions.useRefreshToken !== false) {\n                    const hasRefreshToken = getPath(this, \"state.tokenResponse.refresh_token\");\n                    if (hasRefreshToken) {\n                        return this.refresh().then(() => this.request(\n                            { ...requestOptions, url },\n                            fhirOptions,\n                            _resolvedRefs\n                        ));\n                    }\n                }\n                throw error;\n            })\n\n            // Handle 401 ------------------------------------------------------\n            .catch(async error => {\n                if (error.status == 401) {\n\n                    // !accessToken -> not authorized -> No session. Need to launch.\n                    if (!getPath(this, \"state.tokenResponse.access_token\")) {\n                        throw new Error(\"This app cannot be accessed directly. Please launch it as SMART app!\");\n                    }\n\n                    // !fhirOptions.useRefreshToken -> auto-refresh not enabled\n                    // Session expired. Need to re-launch. Clear state to\n                    // start over!\n                    if (fhirOptions.useRefreshToken === false) {\n                        await this._clearState();\n                        throw new Error(str.expired);\n                    }\n\n                    // otherwise -> auto-refresh failed. Session expired.\n                    // Need to re-launch. Clear state to start over!\n                    await this._clearState();\n                    throw new Error(str.expired);\n                }\n                throw error;\n            })\n\n\n            // Handle raw requests (anything other than json) ------------------\n            .then(data => {\n                if (!data)\n                    return data;\n                if (typeof data == \"string\")\n                    return data;\n                if (typeof data == \"object\" && data instanceof Response)\n                    return data;\n\n                // Resolve References ----------------------------------------------\n                return (async (data) => {\n\n                    if (data) {\n                        if (data.resourceType == \"Bundle\") {\n                            await Promise.all((data.entry || []).map(item => resolveRefs(\n                                item.resource,\n                                fhirOptions,\n                                _resolvedRefs,\n                                this\n                            )));\n                        }\n                        else {\n                            await resolveRefs(\n                                data,\n                                fhirOptions,\n                                _resolvedRefs,\n                                this\n                            );\n                        }\n                    }\n\n                    return data;\n                })(data)\n\n                    // Pagination ------------------------------------------------------\n                    .then(async (data) => {\n                        if (data && data.resourceType == \"Bundle\") {\n                            const links = data.link || [];\n\n                            if (fhirOptions.flat) {\n                                data = (data.entry || []).map(entry => entry.resource);\n                            }\n\n                            if (hasPageCallback) {\n                                await fhirOptions.onPage(data, { ..._resolvedRefs });\n                            }\n\n                            if (--fhirOptions.pageLimit) {\n                                const next = links.find(l => l.relation == \"next\");\n                                data = makeArray(data);\n                                if (next && next.url) {\n                                    const nextPage = await this.request(\n                                        next.url,\n                                        fhirOptions,\n                                        _resolvedRefs\n                                    );\n\n                                    if (hasPageCallback) {\n                                        return null;\n                                    }\n\n                                    if (fhirOptions.resolveReferences && fhirOptions.resolveReferences.length) {\n                                        Object.assign(_resolvedRefs, nextPage.references);\n                                        return data.concat(makeArray(nextPage.data || nextPage));\n                                    }\n                                    return data.concat(makeArray(nextPage));\n                                }\n                            }\n                        }\n                        return data;\n                    })\n\n                    // Finalize --------------------------------------------------------\n                    .then(data => {\n                        if (fhirOptions.graph) {\n                            _resolvedRefs = {};\n                        }\n                        else if (!hasPageCallback && fhirOptions.resolveReferences.length) {\n                            return {\n                                data,\n                                references: _resolvedRefs\n                            };\n                        }\n                        return data;\n                    });\n            });\n    }\n\n    /**\n     * Use the refresh token to obtain new access token. If the refresh token is\n     * expired (or this fails for any other reason) it will be deleted from the\n     * state, so that we don't enter into loops trying to re-authorize.\n     */\n    refresh()\n    {\n\n        const refreshToken = getPath(this, \"state.tokenResponse.refresh_token\");\n        if (!refreshToken) {\n            throw new Error(\"Unable to refresh. No refresh_token found.\");\n        }\n\n        const tokenUri = this.state.tokenUri;\n        if (!tokenUri) {\n            throw new Error(\"Unable to refresh. No tokenUri found.\");\n        }\n\n        const scopes = getPath(this, \"state.tokenResponse.scope\") || \"\";\n        if (scopes.indexOf(\"offline_access\") == -1) {\n            throw new Error(\"Unable to refresh. No offline_access scope found.\");\n        }\n\n        // This method is typically called internally from `request` if certain\n        // request fails with 401. However, clients will often run multiple\n        // requests in parallel which may result in multiple refresh calls.\n        // To avoid that, we keep a to the current refresh task (if any).\n        if (!this._refreshTask) {\n            this._refreshTask = request(tokenUri, {\n                mode   : \"cors\",\n                method : \"POST\",\n                headers: {\n                    \"content-type\": \"application/x-www-form-urlencoded\"\n                },\n                body: `grant_type=refresh_token&refresh_token=${encodeURIComponent(refreshToken)}`\n            }).then(data => {\n                if (!data.access_token) {\n                    throw new Error(\"No access token received\");\n                }\n                return data;\n            }).then(data => {\n                Object.assign(this.state.tokenResponse, data);\n                return this.state;\n            }).catch(error => {\n                delete this.state.tokenResponse.refresh_token;\n                throw error;\n            }).finally(() => {\n                this._refreshTask = null;\n                this.environment.getStorage().set(this.state.key, this.state);\n            });\n        }\n\n        return this._refreshTask;\n    }\n\n    // utils -------------------------------------------------------------------\n    /**\n     * @param {object|object[]} observations\n     * @param {string} property\n     */\n    byCode(observations, property) {\n        return byCode(observations, property);\n    }\n\n    /**\n     * @param {object|object[]} observations\n     * @param {string} property\n     * @returns {(codes: string[]) => object[]}\n     */\n    byCodes(observations, property) {\n        return byCodes(observations, property);\n    }\n\n    get units() {\n        return units;\n    }\n\n    getPath(object, path) {\n        return getPath(object, path);\n    }\n}\n\nmodule.exports = FhirClient;\n","/*\n * This file contains some shared functions. The are used by other modules, but\n * are defined here so that tests can import this library and test them.\n */\n\nconst HttpError = require(\"./HttpError\");\n\n\nfunction isBrowser() {\n    return typeof window === \"object\";\n}\n\n/**\n * Used in fetch Promise chains to reject if the \"ok\" property is not true\n */\nasync function checkResponse(resp) {\n    if (!resp.ok) {\n        throw (await humanizeError(resp));\n    }\n    return resp;\n}\n\n/**\n * Used in fetch Promise chains to return the JSON version of the response.\n * Note that `resp.json()` will throw on empty body so we use resp.text()\n * instead.\n * @param {Response} resp\n * @returns {Promise<object|string>}\n */\nfunction responseToJSON(resp) {\n    return resp.text().then(text => text.length ? JSON.parse(text) : \"\");\n}\n\n/**\n * This is our built-in request function. It does a few things by default\n * (unless told otherwise):\n * - Makes CORS requests\n * - Sets accept header to \"application/json\"\n * - Handles errors\n * - If the response is json return the json object\n * - If the response is text return the result text\n * - Otherwise return the response object on which we call stuff like `.blob()`\n * @param {String|Request} url\n * @param {Object} options\n */\nfunction request(url, options = {}) {\n    return fetch(url, {\n        mode: \"cors\",\n        ...options,\n        headers: {\n            accept: \"application/json\",\n            ...options.headers\n        }\n    })\n        .then(checkResponse)\n        .then(res => {\n            const type = res.headers.get(\"Content-Type\") + \"\";\n            if (type.match(/\\bjson\\b/i)) {\n                return responseToJSON(res);\n            }\n            if (type.match(/^text\\//i)) {\n                return res.text();\n            }\n            return res;\n        });\n}\n\nasync function humanizeError(resp) {\n    let msg = `${resp.status} ${resp.statusText}\\nURL: ${resp.url}`;\n\n    try {\n        const type = resp.headers.get(\"Content-Type\") || \"text/plain\";\n        if (type.match(/\\bjson\\b/i)) {\n            const json = await resp.json();\n            if (json.error) {\n                msg += \"\\n\" + json.error;\n                if (json.error_description) {\n                    msg += \": \" + json.error_description;\n                }\n            }\n            else {\n                msg += \"\\n\\n\" + JSON.stringify(json, null, 4);\n            }\n        }\n        if (type.match(/^text\\//i)) {\n            const text = await resp.text();\n            if (text) {\n                msg += \"\\n\\n\" + text;\n            }\n        }\n    } catch (_) {\n        // ignore\n    }\n\n    throw new HttpError(msg, resp.status, resp.statusText);\n}\n\nfunction stripTrailingSlash(str) {\n    return String(str || \"\").replace(/\\/+$/, \"\");\n}\n\n/**\n * Walks through an object (or array) and returns the value found at the\n * provided path. This function is very simple so it intentionally does not\n * support any argument polymorphism, meaning that the path can only be a\n * dot-separated string. If the path is invalid returns undefined.\n * @param {Object} obj The object (or Array) to walk through\n * @param {String} path The path (eg. \"a.b.4.c\")\n * @returns {*} Whatever is found in the path or undefined\n */\nfunction getPath(obj, path = \"\") {\n    path = path.trim();\n    if (!path) {\n        return obj;\n    }\n    return path.split(\".\").reduce(\n        (out, key) => out ? out[key] : undefined,\n        obj\n    );\n}\n\n/**\n * Like getPath, but if the node is found, its value is set to @value\n * @param {Object} obj The object (or Array) to walk through\n * @param {String} path The path (eg. \"a.b.4.c\")\n * @param {*} value The value to set\n * @returns {Object} The modified object\n */\nfunction setPath(obj, path, value) {\n    path.trim().split(\".\").reduce(\n        (out, key, idx, arr) => {\n            if (out && idx === arr.length - 1) {\n                out[key] = value;\n            } else {\n                return out ? out[key] : undefined;\n            }\n        },\n        obj\n    );\n    return obj;\n}\n\nfunction makeArray(arg) {\n    if (Array.isArray(arg)) {\n        return arg;\n    }\n    return [arg];\n}\n\nfunction absolute(path, baseUrl) {\n    if (path.match(/^http/)) return path;\n    if (path.match(/^urn/)) return path;\n    return baseUrl.replace(/\\/+$/, \"\") + \"/\" + path.replace(/^\\/+/, \"\");\n}\n\n/**\n * Generates random strings. By default this returns random 8 characters long\n * alphanumeric strings.\n * @param {Number} strLength The length of the output string. Defaults to 8.\n * @param {String} charSet A string containing all the possible characters.\n *     Defaults to all the upper and lower-case letters plus digits.\n */\nfunction randomString(strLength = 8, charSet = null) {\n    const result = [];\n\n    charSet = charSet || \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" +\n                         \"abcdefghijklmnopqrstuvwxyz\" +\n                         \"0123456789\";\n\n    const len = charSet.length;\n    while (strLength--) {\n        result.push(charSet.charAt(Math.floor(Math.random() * len)));\n    }\n    return result.join(\"\");\n}\n\nfunction atob(str)\n{\n    if (isBrowser()) {\n        return window.atob(str);\n    }\n\n    // The \"global.\" makes Webpack understand that it doesn't have to include\n    // the Buffer code in the bundle\n    return global.Buffer.from(str, \"base64\").toString(\"ascii\");\n}\n\nfunction btoa(str)\n{\n    if (isBrowser()) {\n        return window.btoa(str);\n    }\n\n    // The \"global.\" makes Webpack understand that it doesn't have to include\n    // the Buffer code in the bundle\n    return global.Buffer.from(str).toString(\"base64\");\n}\n\nfunction jwtDecode(token)\n{\n    const payload = token.split(\".\")[1];\n    return JSON.parse(atob(payload));\n}\n\n/**\n * Groups the observations by code. Returns a map that will look like:\n * {\n *   \"55284-4\": [ observation1, observation2 ],\n *   \"6082-2\" : [ observation3 ]\n * }\n * @param {Object|Object[]} observations Array of observations\n * @param {String} property The name of a CodeableConcept property to group by\n * @returns {Object}\n */\nfunction byCode(observations, property)\n{\n    const ret = {};\n\n    function handleCodeableConcept(concept, observation) {\n        if (concept && Array.isArray(concept.coding)) {\n            concept.coding.forEach(({ code }) => {\n                ret[code] = ret[code] || [];\n                ret[code].push(observation);\n            });\n        }\n    }\n\n    makeArray(observations).forEach(o => {\n        if (o.resourceType === \"Observation\" && o[property]) {\n            if (Array.isArray(o[property])) {\n                o[property].forEach(concept => handleCodeableConcept(concept, o));\n            } else {\n                handleCodeableConcept(o[property], o);\n            }\n        }\n    });\n\n    return ret;\n}\n\n/**\n * First groups the observations by code using `byCode`. Then returns a function\n * that accepts codes as arguments and will return a flat array of observations\n * having that codes\n * @param {Object|Object[]} observations Array of observations\n * @param {String} property The name of a CodeableConcept property to group by\n * @returns {(codes: string[]) => object[]}\n */\nfunction byCodes(observations, property)\n{\n    const bank = byCode(observations, property);\n    return (...codes) => codes\n        .filter(code => (code + \"\") in bank)\n        .reduce((prev, code) => [...prev, ...bank[code + \"\"]], []);\n}\n\nfunction ensureNumerical({ value, code }) {\n    if (typeof value !== \"number\") {\n        throw new Error(\"Found a non-numerical unit: \" + value + \" \" + code);\n    }\n}\n\nconst units = {\n    cm({ code, value }) {\n        ensureNumerical({ code, value });\n        if (code == \"cm\"     ) return value;\n        if (code == \"m\"      ) return value *   100;\n        if (code == \"in\"     ) return value *  2.54;\n        if (code == \"[in_us]\") return value *  2.54;\n        if (code == \"[in_i]\" ) return value *  2.54;\n        if (code == \"ft\"     ) return value * 30.48;\n        if (code == \"[ft_us]\") return value * 30.48;\n        throw new Error(\"Unrecognized length unit: \" + code);\n    },\n    kg({ code, value }){\n        ensureNumerical({ code, value });\n        if(code == \"kg\"    ) return value;\n        if(code == \"g\"     ) return value / 1000;\n        if(code.match(/lb/)) return value / 2.20462;\n        if(code.match(/oz/)) return value / 35.274;\n        throw new Error(\"Unrecognized weight unit: \" + code);\n    },\n    any(pq){\n        ensureNumerical(pq);\n        return pq.value;\n    }\n};\n\n\nmodule.exports = {\n    stripTrailingSlash,\n    absolute,\n    getPath,\n    setPath,\n    makeArray,\n    randomString,\n    isBrowser,\n\n\n    checkResponse,\n    responseToJSON,\n    humanizeError,\n    jwtDecode,\n    request,\n    atob,\n    btoa,\n    byCode,\n    byCodes,\n    units\n};\n","\n/* global HAS_FETCH */\n// HAS_FETCH is a constant defined in our webpack config. It helps us exclude\n// the fetch polyfill from the library build if the targets do not include IE.\n// However, when the code is used as module it becomes part of a project, that\n// gets built with another build tool and the fetch polyfill might not be excluded!\n// @ts-ignore\nif (typeof HAS_FETCH == \"undefined\" || (!HAS_FETCH && typeof window.fetch != \"function\")) {\n    require(\"whatwg-fetch\");\n}\n\n// In Browsers we create an adapter, get the SMART api from it and build the\n// global FHIR object\nconst smart = require(\"./adapters/BrowserAdapter\");\nconst { ready, authorize, init, client, options } = smart();\n\n// $lab:coverage:off$\nmodule.exports = {\n    client,\n    oauth2: {\n        settings: options,\n        ready,\n        authorize,\n        init\n    }\n};\n// $lab:coverage:on$\n","/* global fhir */\nconst BrowserStorage = require(\"../storage/BrowserStorage\");\nconst BaseAdapter    = require(\"./BaseAdapter\");\n\n/**\n * Browser Adapter\n * @type {fhirclient.Adapter}\n */\nclass BrowserAdapter extends BaseAdapter\n{\n    /**\n     * In browsers we need to be able to (dynamically) check if fhir.js is\n     * included in the page. If it is, it should have created a \"fhir\" variable\n     * in the global scope.\n     */\n    get fhir()\n    {\n        // @ts-ignore\n        return typeof fhir === \"function\" ? fhir : null;\n    }\n\n    /**\n     * Given the current environment, this method must return the current url\n     * as URL instance\n     * @returns {URL}\n     */\n    getUrl()\n    {\n        if (!this._url) {\n            this._url = new URL(location + \"\");\n        }\n        return this._url;\n    }\n\n    /**\n     * Given the current environment, this method must redirect to the given\n     * path\n     * @param {String} to The path to redirect to\n     * @returns {void}\n     */\n    redirect(to)\n    {\n        location.href = to;\n    }\n\n    /**\n     * Returns a BrowserStorage object which is just a wrapper around\n     * sessionStorage\n     * @returns {BrowserStorage}\n     */\n    getStorage()\n    {\n        if (!this._storage) {\n            this._storage = new BrowserStorage();\n        }\n        return this._storage;\n    }\n\n    static smart(options)\n    {\n        return new BrowserAdapter(options).getSmartApi();\n    }\n}\n\nmodule.exports = BrowserAdapter.smart;\nmodule.exports.Adapter = BrowserAdapter;\n","class Storage\n{\n    /**\n     * Gets the value at `key`. Returns a promise that will be resolved\n     * with that value (or undefined for missing keys).\n     * @param {String} key\n     * @returns {Promise<any>}\n     */\n    async get(key)\n    {\n        const value = sessionStorage[key];\n        if (value) {\n            return JSON.parse(value);\n        }\n        return null;\n    }\n\n    /**\n     * Sets the `value` on `key` and returns a promise that will be resolved\n     * with the value that was set.\n     * @param {String} key\n     * @param {any} value\n     * @returns {Promise<any>}\n     */\n    async set(key, value)\n    {\n        sessionStorage[key] = JSON.stringify(value);\n        return value;\n    }\n\n    /**\n     * Deletes the value at `key`. Returns a promise that will be resolved\n     * with true if the key was deleted or with false if it was not (eg. if\n     * did not exist).\n     * @param {String} key\n     * @returns {Promise<Boolean>}\n     */\n    async unset(key)\n    {\n        if (key in sessionStorage) {\n            delete sessionStorage[key];\n            return true;\n        }\n        return false;\n    }\n\n}\n\nmodule.exports = Storage;\n","const smart  = require(\"../smart\");\nconst Client = require(\"../Client\");\n\n/**\n * This is the abstract base class that adapters must inherit. It just a\n * collection of environment-specific methods that subclasses have to implement.\n * @type { fhirclient.Adapter }\n */\nclass BaseAdapter\n{\n    /**\n     * @param {Object} options Environment-specific options\n     */\n    constructor(options = {})\n    {\n        this.options = {\n            // Replaces the browser's current URL\n            // using window.history.replaceState API or by reloading.\n            replaceBrowserHistory: true,\n\n            // When set to true, this variable will fully utilize\n            // HTML5 sessionStorage API.\n            // This variable can be overridden to false by setting\n            // FHIR.oauth2.settings.fullSessionStorageSupport = false.\n            // When set to false, the sessionStorage will be keyed\n            // by a state variable. This is to allow the embedded IE browser\n            // instances instantiated on a single thread to continue to\n            // function without having sessionStorage data shared\n            // across the embedded IE instances.\n            fullSessionStorageSupport: true,\n\n            ...options\n        };\n    }\n\n\n    getUrl() {\n        return new URL(\"\");\n    }\n\n    getStorage() {}\n\n    /**\n     * @param {String} path\n     */\n    relative(path)\n    {\n        return new URL(path, this.getUrl().href).href;\n    }\n\n    /**\n     * Creates and returns adapter-aware SMART api. Not that while the shape of\n     * the returned object is well known, the arguments to this function are not.\n     * Those who override this method are free to require any environment-specific\n     * arguments. For example in node we will need a request, a response and\n     * optionally a storage or storage factory function.\n     * @returns { fhirclient.SMART }\n     */\n    getSmartApi()\n    {\n        return {\n            ready    : (...args) => smart.ready(this, ...args),\n            authorize: options   => smart.authorize(this, options),\n            init     : (...args) => smart.init(this, ...args),\n            client   : state     => new Client(this, state),\n            options  : this.options\n        };\n    }\n}\n\nmodule.exports = BaseAdapter;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","\nclass HttpError extends Error\n{\n    constructor(message, statusCode, statusText) {\n        super(message);\n        this.message    = message;\n        this.name       = \"HttpError\";\n        this.statusCode = statusCode;\n        this.status     = statusCode;\n        this.statusText = statusText;\n    }\n\n    toJSON() {\n        return {\n            name      : this.name,\n            statusCode: this.statusCode,\n            status    : this.status,\n            statusText: this.statusText,\n            message   : this.message\n        };\n    }\n\n    static create(failure) {\n        // start with generic values\n        var status     = 0;\n        var statusText = \"Error\";\n        var message    = \"Unknown error\";\n\n        if (failure) {\n            if (typeof failure == \"object\") {\n                if (failure instanceof Error) {\n                    message = failure.message;\n                }\n                else if (failure.error) {\n                    status = failure.error.status || 0;\n                    statusText = failure.error.statusText || \"Error\";\n                    if (failure.error.responseText) {\n                        message = failure.error.responseText;\n                    }\n                }\n            }\n            else if (typeof failure == \"string\") {\n                message = failure;\n            }\n        }\n\n        return new HttpError(message, status, statusText);\n    }\n}\n\nmodule.exports = HttpError;\n","// This map contains reusable debug messages (only those used in multiple places)\nmodule.exports = {\n    expired      : \"Session expired! Please re-launch the app\",\n    noScopeForId : \"Trying to get the ID of the selected %s. Please add 'launch' or 'launch/%s' to the requested scopes and try again.\",\n    noIfNoAuth   : \"You are trying to get %s but the app is not authorized yet.\",\n    noFreeContext: \"Please don't use open fhir servers if you need to access launch context items like the %S.\"\n};\n"],"sourceRoot":""}